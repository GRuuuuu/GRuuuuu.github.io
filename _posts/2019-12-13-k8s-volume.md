---
title: "Kubernetes Volumes : Static & Dynamic Provisioning"
categories: 
  - Container
tags:
  - Kubernetes
  - Controller
  - Volume
  - NFS
  - PersistentVolume
last_modified_at: 2019-12-13T13:00:00+09:00
author_profile: true
sitemap :
  changefreq : daily
  priority : 1.0
---

## 1. Overview
이번 문서에서는 `Kubernetes`(k8s)의 여러 볼륨에 대해서 알아보겠습니다.  

## 2. Prerequisites

본문에서 사용한 spec :  
`OS : CentOS v7.6`  
`Arch : x86`  

k8s클러스터는 1마스터 2노드로 구성했습니다.  
`Master` : 4cpu, ram16G  
`Node` : 2cpu, ram4G  

# 3. Volumes
쿠버네티스에서의 볼륨은 pod에 종속되는 디스크입니다. 다시말해, 같은 pod에 있는 컨테이너들은 해당 디스크를 공유해서 사용할 수 있습니다.  
## EmptyDir
pod과 함께 생성되고 삭제되는 **임시 볼륨**입니다. 아무런 volume옵션을 주지 않았을 때 생성됩니다.   

## Host Path
로컬 디스크의 경로를 pod에 마운트해서 사용하는 방식입니다.  

**pod이 올라간 노드의 로컬디스크를 사용**하는 것이기 때문에 <u>해당 노드의 로컬 마운트 포인트가 존재</u>하는지 확인해야 합니다.  

또한 pod이 재시작되어 다른노드에서 기동될 경우에, 해당 노드의 로컬디스크를 사용하기 때문에 이전 노드에서 사용했던 로컬디스크는 액세스할 수 없게 됩니다.  

노드의 **파일시스템을 접근**하는데 유용한 특성을 가지고 있으므로 노드의 로그파일을 읽어서 수집하는 **로그 에이전트**같은 경우에 유용하게 사용할 수 있습니다.  

### 실습

~~~sh
$ vim hostpath-nginx.yaml

apiVersion: v1
kind: Pod
metadata:
  name: hostpath-nginx
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts: # pod의 path
    - name: volumepath
      mountPath: /usr/share/nginx/html
  volumes:
  - name : volumepath
    hostPath: # 반드시 노드에 해당 path가 있는지 확인할 것
      path: /root/hostdir
      type: Directory
~~~

pod 실행 :   
~~~sh
$ kubectl apply -f hostpath-nginx.yaml
$ kubectl get pod
~~~
![image](https://user-images.githubusercontent.com/15958325/70773891-07caa680-1dbc-11ea-8e07-59825bb596ec.png)  


pod이 어디떠있는지 확인 :  
~~~sh
$ kubectl describe pod hostpath-nginx
~~~
![image](https://user-images.githubusercontent.com/15958325/70773928-2a5cbf80-1dbc-11ea-8ef8-77d222c838bb.png)  

2번 노드에 떠있습니다.  

2번 노드에 접속해서 해당 path에 파일을 하나 생성해봅시다.  
![image](https://user-images.githubusercontent.com/15958325/70773982-482a2480-1dbc-11ea-9bd5-d3c991211091.png)  


nginx앱 안에 들어가서 마운트 포인트를 확인해봅니다.  
~~~sh
$ kubectl exec -it hostpath-nginx /bin/bash
~~~
![image](https://user-images.githubusercontent.com/15958325/70774033-6a23a700-1dbc-11ea-9f45-25c37b2e7f7d.png)  
방금전 2번 노드에서 생성한 파일이 그대로 보이는것을 확인할 수 있습니다.  

## PersistentVolume & PersistentVolumeClaim
임시나 로컬 디스크가 아닌 디스크 볼륨을 설정하려면 물리적인 스토리지를 생성해야하고, 관리까지 할 줄 알아야합니다. 이는 개발자들에게 있어 상당한 부담이 될 수 있습니다.   

쿠버네티스는 인프라에 대한 복잡성을 추상화시키고 개발자들이 손쉽게 인프라 자원을 사용할 수 있도록 하는 개념을 가지고 있습니다.  

* 시스템관리자 : 인프라에 대한 것들만  
* 개발자 : 개발에 관한 것만  

각자의 역할에 집중할 수 있도록 `PersistentVolume`(pv)과 `PersistentVolumeClaim`(pvc)이라는 개념을 도입하였습니다.  

기본 시나리오 :   
![Picture1](https://user-images.githubusercontent.com/15958325/70780659-6433c300-1dc8-11ea-877b-b34a02a1cec2.png)  

시스템 관리자가 실제 스토리지를 생성하고, 이 디스크를 `PersistentVolume`으로 쿠버네티스에 등록합니다.  
개발자는 pod을 생성할 때, 볼륨을 정의하고 이 부분에 `PersistentVolumeClaim`을 지정하여 시스템 관리자가 생성한 pv와 연결합니다.  

### 실습
> 실습을 진행하기 전에, 물리적인 스토리지가 하나 반드시 필요합니다.  
> 이 문서에서는 `nfs`를 사용하도록 하겠습니다.  
> 참고링크 : [호롤리한하루/NFS 기초 연결 (LINUX)](https://gruuuuu.github.io/linux/basic-nfs/)  

실제 스토리지와 연동되는 `PersistentVolume`을 만들어봅시다.  
~~~sh
$ vim create-pv.yaml

apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv
spec:
  capacity:
    storage: 20Gi
  accessModes:
    - ReadWriteMany
  nfs:
    server: x.x.x.x
    path: /mount/point
~~~

> **accessMode** :  
>- `ReadWriteOnce(RWO)` : 하나의 pod에만 마운트되고 하나의 pod에서만 읽고쓰기 가능.  
>- `ReadOnlyMany(ROX)` : 여러개의 pod에 마운트가능, 여러개의 pod에서 동시에 읽기 가능, 쓰기는못함.
>- `ReadWriteMany(RWX)` : 여러개의 pod에 마운트가능, 여러개의 pod에서 읽고쓰기 가능.  

pod에서 어느정도의 볼륨을 사용할 것인지 `PersistentVolumeClaim`에 정의해줍니다.  
~~~sh
$ vim claim-pvc.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 20Gi
~~~


~~~sh
$ kubectl create -f create-pv.yaml
$ kubectl create -f claim-pvc.yaml
~~~

![image](https://user-images.githubusercontent.com/15958325/70785664-4e290100-1dce-11ea-8937-2318127253e5.png)  





