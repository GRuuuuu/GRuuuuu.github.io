---
title: "Tekton이란?"
categories: 
  - Cloud
tags:
  - Kubernetes
  - Tekton
  - CICD
  - DevOps
last_modified_at: 2021-06-06T13:00:00+09:00
author_profile: true
toc: true
sitemap :
  changefreq : daily
  priority : 1.0
---

## Overview
작년에 `Knative`를 다루면서 잠깐 `Tekton`에 대한 얘기를 언급한 적이 있는데요, 이번에 Tekton을 다뤄볼 기회가 생겨 블로그에도 간단히 정리를 해두려 합니다.  

`Kubernetes`가 Container Orchestration계의 de-facto가 되고나서 여러 툴들이 각자 영역의 de-facto로 자리잡았지만, 아직 CI/CD쪽은 뚜렷한 강자가 없는 것으로 알고 있습니다.  

그런데 왜 `Tekton`을 골라서 공부를 시작했느냐!  
GA된지는 얼마 안된 신생 프로젝트이지만, 여러 곳에서 Tekton을 사용하고 있습니다.  
예를들어 전통의 강자 Jenkins의 후예 `Jenkins X`에서도 pipeline으로 tekton을 사용하고 있고, `Openshift`에서도 4.7버전부터 자체 pipeline서비스로 Tekton을 추가하였습니다.  

다른 pipeline툴들에 비해 어느정도 성능이 나오고 어떤 기능이 좋은가는 아직 모르겠지만 일단 여러 메이저 툴들이 Tekton을 쓰고있고 쿠버네티스를 위해 처음부터 설계된 툴이니만큼 앞으로도 더 발전할 툴이라고 생각합니다.  
(그리고 로고가 귀여워요ㅎㅎ)  

>(21.06.06) 해당 문서는 Tekton Pipeline `v0.24.1` 을 기준으로 제작되었습니다.  

# Tekton?
## Tekton 이란?
![image](https://user-images.githubusercontent.com/15958325/120922505-83cd5280-c704-11eb-904a-ffecfeecff18.png)  

**Tekton**은 CI/CD 파이프라인을 빠르게 구축하기 위한 프레임워크를 제공하는 Cloud-native 오픈소스 프로젝트입니다.([CD foundation Project](https://cd.foundation/))  

Tekton의 구성 요소들은 Kubernetes의 CRD(Custom Resource Definitions)로 정의되어 다른 pod이나 resource와 같이 Kubernetes CLI와 API call로 사용할 수 있습니다.  

## Tekton의 특징

- **재사용** : tekton의 모든 task들은 다른 pipeline과 완전히 독립적으로 사용할 수 있습니다. 즉 모듈화가 잘 되어있어 여러 pipeline에서 필요한 task들을 갖다 쓸 수 있습니다.  
- **표준화** : Tekton은 Kubernetes의 Custom Resource를 사용해 정의됩니다.  
- **기능의 확장성** : Tekton Hub를 통해 Tekton커뮤니티에서 제작한 여러 종류의 task들을 사용할 수 있습니다.  


## 구조
Tekton파이프라인은 크게 4가지 Component들로 구성되며 Kubernetes의 Custom Resource로 정의됩니다.   
- `Task`
- `TaskRun`
- `Pipeline`
- `PipelineRun`

### Step
`Step`하나는 작업하나라고 생각하시면 됩니다.  
예를들어 Python app의 유닛테스트라던지, Java app의 compile작업, Git Clone 등 하나의 작업 모듈을 Step이라고 합니다.  

### Task
`Task`는 Step들의 모음입니다. Task하나당 하나의 Pod으로 동작합니다.

### Pipeline 
![image](https://user-images.githubusercontent.com/15958325/120925385-605dd400-c713-11eb-9c58-34621c9df167.png)  

`Pipeline`은 task들의 모음입니다. Pipeline 속 task들은 순차적으로 실행되게 됩니다.  
task의 `RunAfter`구문을 통해 이전 task가 끝난 뒤 다음 task가 실행되게 할 수 있습니다.  

### TaskRun
단일 **Task를 실행**시키는 역할을 합니다.  
Task를 실행시킬 때의 서비스어카운트, 사용할 리소스 정의, task들의 pod설정 등을 할 수 있습니다.  

### PipelineRun
마찬가지로 이름에서 알 수 있듯이 **Pipeline을 실행**시키는 역할을 합니다.  
Pipeline이 실행될 때 Pipeline 내 task들은 `workspace`라는 이름의 볼륨을 공유하게 할 수 있습니다.  

TaskRun과 마찬가지로 각 Task가 실행될 때의 서비스어카운트, `workspace`정의, 파라미터, pod설정 등을 할 수 있습니다.  

`PipelineRun`을 실행시키면 각 Task에 해당하는 **TaskRun을 자동으로 생성시켜 실행하기** 때문에 별도로 TaskRun을 정의해주지 않아도 됩니다.  

### Workspace
Workspace는 **Task들의 볼륨으로 사용**됩니다.  
Task별로 사용할 workspace를 지정할 수 있으며, Task를 실행시키는 TaskRun이나 PipelineRun에서 실제 볼륨을 workspace에 붙여줄 수 있습니다. (`PVC`또는 `EmptyDir`)  

예를 들어, 다음과 같은 task들을 정의해둔 Pipeline이 있다고 합시다.  

**task 1. clone git repository**  
**task 2. build repository**

깃 레포를 클론해서 -> 빌드하는 간단한 파이프라인입니다.  

Task별로 Pod을 따로 생성하게 될거고,  
클론한 레포를 빌드해야하니 이 두개의 Pod은 리소스를 공유하고 있어야 합니다.  
이때 별개의 Task간의 공유 스토리지가 **Workspace**가 됩니다.  

Workspace는 `PVC`를 붙여줄 수도 있고 `EmptyDir`을 붙여줄 수도 있습니다.  
Task하나를 실행시킬 시에는 딱히 다른 pod과 공유할 필요가 없기때문에 `EmptyDir`로 붙여줘도 되지만,  
Task가 여러개이고 위 예시와 같이 선행 task의 output을 가지고 작업을 해야하는 경우 공유되는 스토리지가 필요하기때문에 물리적인 리소스(PVC)를 붙여주어야 합니다.  

그래서 위 예시는 다음과 같은 flow로 진행될 것입니다:  
PV-PVC간 Bound -> PVC를 `Workspace`로 사용하겠다고 `PipelineRun`에 선언 (Task에서도 어떤 workspace를 사용할 건지 지정) -> Task 1번 pod이 workspace(pvc)와 Bind -> 깃 레포를 `Workspace`에 클론 -> Task1번 pod unbound -> Task 2번 pod과 workspace(pvc) Bind -> `Workspace`에 접근해서 빌드 작업 수행 -> Task 2번 pod unbound   

조금 복잡하긴 하지만 이 뒤의 포스팅에서 직접 Hands-On을 해보면 쉽게 이해하실 수 있을겁니다.  

그 런 데 !!!!  
여기까지 읽으신 분들은 하나 궁금증이 드실겁니다.  

**"PV와 PVC가 RWO(Read-Write-Only) accessmode로 설정될 경우 어떻게 여러 Pod에서 PVC에 Bound가 될 수 있지???"**

(왜냐면 제가 궁금했기 때문^^)

기본적으로 PVC는 





































