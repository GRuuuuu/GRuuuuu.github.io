var store = [{
        "title": "01.hyperledger sawtooth를 docker for window에서 돌릴수있게 해보자!",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for windows(18.03.01-ce-win65)에서 다루며 os는 window 10 pro임   1. Docker for windows설치   Install Docker for windows   2. Starting Sawtooth   도커의 초기설정이 끝나고 도커를 켜기 전에 원하는 위치에 폴더를 생성합니다.  이후, 이 문서에 첨부되어있는 sawtooth-default.yaml을  생성한 폴더에 다운받아 주세요.   그다음 도커를 실행해보도록 하겠습니다.      powershell이든 cmd이든 상관없지만 이 문서에서는  Windows PowerShell을 사용하도록 하겠습니다.   다음 커맨드를 실행하여 Sawtooth이미지를 다운받습니다. 주의 해야할 점은 이 커맨드를 사용할 폴더에 sawtooth-default.yaml이 있어야 합니다.  % docker-compose -f sawtooth-default.yaml up     전부 다운이 받아지면 docker의 kitematic을 켜서 확인할 수 있습니다.     돌아가고있는것을 확인할 수 있습니다.   3. Stopping Sawtooth   sawtooth를 종료하려면 CTRL-c를 몇 회 누른 뒤,  % docker-compose -f sawtooth-default.yaml down  커맨드를 입력합니다. 이를 통해 완전히 종료할 수 있습니다.   4. Logging Into The Client Contatiner   이 커맨드를 통해 sawtooth가 실행중인 상태여야 합니다.  % docker-compose -f sawtooth-default.yaml up   sawtooth가 실행중인 상태에서 다음 커맨드를 통해 client container에 접근할 수 있습니다.  % docker exec -it sawtooth-shell-default bash    root~~~이런식으로 실행되면 성공입니다   Confirming Connectivity   Validator가 동작중인것을 확인하기 위해 root에서 curl커맨드를 사용할 수 있습니다.  /# curl http://rest-api:8008/blocks  만약 validator가 실행중이고 접근이 가능하다면 output은 이런식으로 비슷하게 출력될 것입니다.      만약 validator에 문제가 있다면 curl커맨드는 타임아웃하거나 아무것도 반환하지 않을것입니다.   5. Using Sawtooth Commands   Creating and Submitting Transactions with intkey   intkey 커맨드는 간단한 샘플 트랜잭션을 생성하여 테스팅할수있게 합니다. intkey커맨드는 뭔가 엄청 중요한 커맨드가 아니라 단순히 테스팅하는 용도로 사용하는 커맨드라고 생각하면 조금 머리가 편해집니다.   다음 스텝은 intkey를 사용하여 intkey transactions의 랜덤값을 가진 몇개의 key로 구성된 배치파일을 생성하게됩니다. 이 배치파일은 로컬에 저장되고 validator에 전달합니다.  $ intkey create_batch --count 10 --key-count 5 $ intkey load -f batches.intkey -U http://rest-api:8008      Viewing the List of Blocks &amp; Particular Block   다음 커맨드를 통해 블록의 리스트를 확인할 수 있습니다.  $ sawtooth block list --url http://rest-api:8008    방금전에 사용했던 intkey커맨드의 결과로 생성된 블록들을 확인할 수 있습니다.   특정 블록의 상태를 확인하고 싶다면 다음 커맨드를 이용합니다. BLOCK_ID에는 리스트에서 확인한 아이디중 하나를 집어넣으면 됩니다.  $ sawtooth block show --url http://rest-api:8008 {BLOCK_ID}    블럭의 상태를 확인할 수 있습니다. 헤더, 헤더의 시그니처, 트랜잭션등을 확인할 수 있습니다.   Viewing Global State   다음 커맨드로 머클트리의 노드리스트를 확인할 수 있습니다.  $ sawtooth state list --url http://rest-api:8008     Viewing Data at an Address  sawtooth state list커맨드를 통해 나온 address로 data를 확인할 수 있습니다.  $ sawtooth state show --url http://rest-api:8008 {STATE_ADDRESS}     6. Connecting to the REST API  curl를 사용해 REST API에 접근할 수 있습니다.   From Client Containter  클라이언트 컨테이너에서는 다음 커맨드를 사용합니다.  $ curl http://rest-api:8008/blocks   From Host Operating System  호스트 시스템에서는 다음 커맨드를 사용합니다.  $ curl http://localhost:8008/blocks   7. Connecting to Each Container   The Client Container      트랜잭션 submit   sawtooth 커맨드 실행   Container name : sawtooth-shell-default   % docker exec -it sawtooth-shell-default bash   The Validator Container      단일 Validator 실행   port 4004(default)에서 사용가능   Hostname : validator   Container name : sawtooth-validator-default   $ docker exec -it sawtooth-validator-default bash   The REST API Container      REST API 실행   port 8008에서 사용가능   Container name : sawtooth-rest-api-default   $ docker exec -it sawtooth-rest-api-default bash   The Settings Transaction Processor Container      단일 Setting Transaction 프로세서 실행   Setting Transaction 패밀리의 트랜잭션을 다룸   Hostname : settings-tp   Container name : sawtooth-settings-tp-default   $ docker exec -it sawtooth-settings-tp-default bash   The IntegerKey Transaction Processor Container      단일 IntegerKey Transaction 프로세서 실행   IntegerKey Transaction 패밀리의 트랜잭션을 다룸   Hostname : intkey-tp-python   Container name : sawtooth-intkey-tp-python-default   $ docker exec -it sawtooth-intkey-tp-python-default bash   The XO Transaction Processor Container      단일 XO Transaction 프로세서 실행   XO Transaction 패밀리의 트랜잭션을 다룸   Hostname : xo-tp-python   Container name : sawtooth-xo-tp-python-default   $ docker exec -it sawtooth-xo-tp-python-default bash   위의 컴포넌트가 실행되고있는 것을 확인하려면 ps커맨드를 사용    8. Viewing Log Files   로그파일을 보기 위해서는 다음 커맨드를 사용  {CONTAINER}에는 sawtooth-validator-default같은 컨테이너 이름이 들어가야한다.  $ docker logs {CONTAINER}   9. 마치며   본 문서는 hyperledger sawtooth docs 의 튜토리얼을 보고 따라해본 문서입니당       ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter01/",
        "teaser":null},{
        "title": "02.XO Transaction Family",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for windows(18.03.01-ce-win65)에서 다루며 os는 window 10 pro임   1. XO게임?  XO는 Sawtooth SDK에 포함되어있는 transaction family 예제임. 쉽게 틱택토라고 생각하면 됨. 2인용 게임이며 보통 3x3크기의 테이블에 한명씩 돌아가면서 마킹을 하게 되고 1줄을 먼저 잇는사람이 우승하는 게임  틱택토에 대해 더 자세한 설명은 여기   2. Playing XO with the XO Client   XO게임을 시작하기 전에 필요한것들     최소 하나의 validator   XO family transaction processor   The REST API   먼저 sawtooth를 실행해줍니다.  % docker-compose -f sawtooth-default.yaml up   다음 sawtooth-shell-default bash를 실행해줍니다.  % docker exec -it sawtooth-shell-default bash   Create Players   게임에 참여할 두명의 플레이어의 키를 생성합니다.  $ sawtooth keygen jack $ sawtooth keygen jill      Create a Game   다음으로는 게임을 진행할 게임판을 생성해야합니다.  $ xo create {Game name} --username jack --url http://rest-api:8008   username의 파라미터값으로 온 jack은 Player1이 됩니다.   다음 이미지와 같이 Response가 온다면 제대로 게임이 생성된 것입니다.        간혹 --url을 적지 않으면    Error: Failed to connect to http://127.0.0.1:8008/batches: HTTPConnectionPool(host='127.0.0.1', port=8008): Max retries exceeded with url: /batches (Caused by NewConnectionError('&lt;requests.packages.urllib3.connection.HTTPConnection object at 0x7f78baf33cc0&gt;: Failed to establish a new connection: [Errno 111] Connection refused',))      이런 오류가 생기는데 url을 적어주면 문제가 해결됩니다.     XO클라이언트는 부분적으로 인증을 지원합니다. 그래서 REST API가 인증프록시에 연결되어있다면 xo커맨드를 사용할때 --url인자를 추가해주어야합니다.    생성한 게임의 리스트를 확인하기 위해서는 다음 커맨드를 사용합니다.   $ xo list --url http://rest-api:8008       현재 생성한 게임인 example을 확인하기 위해서는 다음 커맨드를 사용합니다.  $ xo show {Game name} --url http://rest-api:8008      현재 게임의 상태 : Player1(Jack)의 차례  게임판에 아무런 마킹이 없는 것을 확인할 수 있습니다.   Playing   Player1과 Player2가 차례로 마킹해보도록 하겠습니다.  $ xo take game 5 --username jack --url http://rest-api:8008 $ xo take game 1 --username jill --url http://rest-api:8008     $ xo show {Game name} --url http://rest-api:8008    5번자리와 1번자리에 마킹된 모습을 확인할 수 있습니다.   Unexpected Event           자신의 차례가 아닌데 마킹하려는 경우  Player1의 차례에 Player2가 마킹을 시도  요청이 반영되지 않는것을 확인할 수 있다.            이미 마킹되어 있는곳에 마킹을 시도  위와 마찬가지로 요청이 반영되지 않는다.       Game End   게임이 종료되는 경우는 두가지로     한 명의 플레이어가 한 줄을 이었을 경우   모든 칸이 마킹되어 더이상 마킹할 칸이 남아있지 않을 경우   Plyaer1이 이긴 경우(P1-WIN)    더이상 마킹할 칸이 남아있지 않은 경우(TIE)         ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter02/",
        "teaser":null},{
        "title": "03.Transaction Processor Tutorial Java 1",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for windows(18.03.01-ce-win65)에서 다루며 os는 window 10 pro임   1. Overview  이전 문서에서는 xo게임을 powershell환경에서 실행해보는것을 해봤습니다. 이번 문서에서는 Sawtooth SDK에 기반하여 Java언어로 구성된 Sawtooth transaction family를 다뤄보겠습니다. 소스코드에 관한 자세한 설명은 다음문서에서 계속!     첨부된 sdk폴더에는 xo게임의 완전히 구현된 버전이 포함되어있습니다. 이번 문서와 다음문서에서는 완전한 구현을 만드는 대신 만들어진 소스코드의 개념을 설명하는 것에 초점을 맞췄습니다. SDK는 여러 언어로 구성되어있으므로 여기 를 참조해주세요.    2. Prerequisites   이전문서에서 xo게임을 실행까지 성공하고 따라해주세요.   Download Java sdk      Intellij에서 프로젝트를 만들었습니다.    첨부된 sawtooth폴더와 protos폴더, pom.xml를 다운로드  첨부된 파일들은 이곳을 참고   Java project를 생성한 뒤, sawtooth폴더는 src밑으로, protos와 pom.xml은 각각 알아서 추가해줍시다.      프로젝트 구성을 마치고나서 build하게되면 pom.xml에 적힌 dependancy가 외부라이브러리로 다운받아지게되고 소스코드의 빨간줄이 사라지게 됩니다. (야-호!)      이 구성을 제대로 설명해둔데가 없어서 매우 고생함^^    Address Setting   자바 프로그램을 빌드하기 전, main파라미터의 값으로 sawtooth가 돌아가고있는 도커의 ip와 포트를 적어줘야 합니다.    TransactionProcessor transactionProcessor = new TransactionProcessor(\"tcp://validator의ip(도커의ip):4004\");   만약 로컬에서 돌리고있다면 이렇게 적어주면 됩니다.   TransactionProcessor transactionProcessor = new TransactionProcessor(\"tcp://localhost:4004\");   3. Run   Run program   sawtooth-shell-default bash가 실행되고 있는 상태부터 시작  구성을 끝낸 뒤의 자바 프로그램을 실행해봅시다.  현재는 아무런 트랜잭션이 오고가고 있지 않으므로 빈 화면입니다.    두명의 플레이어의 key를 구성해준뒤, 게임판을 만들어봅시다.  자바 프로그램에 game을 만들었다는 화면이 디스플레이 됩니다.   다음 첫번째 플레이어부터 마킹을 시작해봅시다.  java프로그램에서 트랜잭션의 결과를 확인할 수 있습니다.   트랜잭션이 실패하였을 때 exception처리도 이곳에서 확인할 수 있습니다.        ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter03/",
        "teaser":null},{
        "title": "04.Transaction Processor Tutorial Java 2",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for windows(18.03.01-ce-win65)에서 다루며 os는 window 10 pro임   1. Overview  이번 문서에서는 이전 문서에서 실행해보았던 Java 코드의 핵심 모듈을 뜯어보겠습니다. ^ㅇ^!   2. Prerequisites   이전문서   3. 소스코드 뜯   XoTransactionProcessor.java   프로그램의 시작점입니다.  public class XoTransactionProcessor {   /**    * TransactionProcessor가 들어있는 Thread를 실행    */   public static void main(String[] args) {     /*     * args[0]에 들어가야할 것      * tcp://validator의ip또는 docker의 ip:4004     */     TransactionProcessor transactionProcessor = new TransactionProcessor(args[0]);     transactionProcessor.addHandler(new XoHandler());     Thread thread = new Thread(transactionProcessor);     thread.start();   } }  TransactionProcessor에서는 validator의 ip나 docker의 ip를 받아 포트 4004로 sawtooth와 연결.  핸들러로 XoHandler를 추가, 그다음 thread로 실행시킵니다.   XoHandler.java   TransactionHandler를 implements하여 API를 오버라이드하여 다양한 메소드를 활용할 수 있습니다.   - XoHandler  public XoHandler() {     try {       this.xoNameSpace = Utils.hash512(         this.transactionFamilyName().getBytes(\"UTF-8\")).substring(0, 6);     } catch (UnsupportedEncodingException usee) {       usee.printStackTrace();       this.xoNameSpace = \"\";     }   }    @Override   public String transactionFamilyName() {       /*transaction의 family name을 리턴*/     return \"xo\";   }    @Override   public String getVersion() {       /*현재 버전 리턴*/     return \"1.0\";   }    @Override   public Collection&lt;String&gt; getNameSpaces() {     ArrayList&lt;String&gt; namespaces = new ArrayList&lt;&gt;();     namespaces.add(this.xoNameSpace);     return namespaces;   }      사용할 TransactionData와 GameData를 구성    class TransactionData {     final String gameName;     final String action;     final String space;      TransactionData(String gameName, String action, String space) {       this.gameName = gameName;       this.action = action;       this.space = space;     }   }    class GameData {     final String gameName;     final String board;     final String state;     final String playerOne;     final String playerTwo;      GameData(String gameName, String board, String state, String playerOne, String playerTwo) {       this.gameName = gameName;       this.board = board;       this.state = state;       this.playerOne = playerOne;       this.playerTwo = playerTwo;     }   }       - apply메소드   /*   * apply메소드는 두개의 argument를 받습니다.   * transactionRequest : 실행된 커맨드를 받습니다. (예: take space, create game)   * stateStore : 게임의 현재상태를 저장한 상태정보   * */   @Override   public void apply(TpProcessRequest transactionRequest, State stateStore)       throws InvalidTransactionException, InternalError {      //리퀘스트 데이터를 unpack해서 transactionData에 저장     TransactionData transactionData = getUnpackedTransaction(transactionRequest);      // transaction의 서명자는 플레이어     String player;     TransactionHeader header = transactionRequest.getHeader();     player = header.getSignerPublicKey();      /*이 밑으로는 처음 트랜잭션을 받았을 때 처리해야할 exception들을 정의해둠*/     if (transactionData.gameName.equals(\"\")) { //게임이름이 빠진경우       throw new InvalidTransactionException(\"Name is required\");     }     if (transactionData.gameName.contains(\"|\")) {//게임이름의 특수경우       throw new InvalidTransactionException(\"Game name cannot contain '|'\");     }     if (transactionData.action.equals(\"\")) {//액션이빠짐       throw new InvalidTransactionException(\"Action is required\");     }     if (transactionData.action.equals(\"take\")) {//take 커맨드 사용       try {         int space = Integer.parseInt(transactionData.space); //마킹할 장소(space)          if (space &lt; 1 || space &gt; 9) {//마킹할 장소는 1~9사이여야함           throw new InvalidTransactionException(               String.format(\"Invalid space: %s\", transactionData.space));         }       } catch (NumberFormatException e) {         throw new InvalidTransactionException(\"Space could not be converted to an integer.\");       }     }     /*커맨드가 take와 create가 아닌 경우*/     if (!transactionData.action.equals(\"take\") &amp;&amp; !transactionData.action.equals(\"create\")) {       throw new InvalidTransactionException(           String.format(\"Invalid action: %s\", transactionData.action));     }      String address = makeGameAddress(transactionData.gameName);     // stateStore.get() returns a list.     // If no data has been stored yet at the given address, it will be empty.     // 현재상태의 주소값을 가져옴. singletonList: 생성후 변경불가능한객체     String stateEntry = stateStore             .getState(Collections.singletonList(address))//만든 게임의 상태             .get(address) //그 상태의 주소             .toStringUtf8();          //현재 게임의 상태를 stateData에 저장     GameData stateData = getStateData(stateEntry, transactionData.gameName);          //상태데이터와 커맨드데이터, 누가(주체)플레이중인지 로 업데이트된 게임데이터     GameData updatedGameData = playXo(transactionData, stateData, player);          //저-장 (게임의주소, 업데이트된 게임데이터, 현재게임상태 주소, 현재게임상태)     storeGameData(address, updatedGameData, stateEntry, stateStore);   }     나머지 메소드는 생략    ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter04/",
        "teaser":null},{
        "title": "05.Connect multi validator in local server",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for windows(18.03.01-ce-win65)에서 다루며 os는 window 10 pro임   1. Overview  이번 문서에서는 여태까지 단일 validator에서 진행하던 sawtooth network를 키워서 멀-티 validator를 만들어보도록 하겠습니다! 로컬환경에서 진행하겠습니다. 다른 네트워크상에서 이어보는건 다음문서에서!   2. Prerequisites   공식 doc에서는 validator를 4개를 사용하여 연결되는 것을 보여주고있습니다.  –&gt; 참고링크   이 문서에서는 보다 간편하게 설명하기 위해서 validator 2개만 가지고 설명할것임.  우선 요걸 다운로드 받아주세요   3. 일단 실행   다운로드받은 yaml파일이 있는 폴더로 이동해서 shell(이하 shell-1)에서 다음 커맨드를 쳐봅시다  docker-compose -f sawtooth-default-poet.yaml up  yaml파일에 미리 기록해두었던 이미지들이 실행될겁니다. 정상적으로 실행된다면 다음과같은 화면이 보일거에요.      연결확인   지금 켜져있는 shell-1을 끄지말고(로그 확인용) 하나 더켜서(이하 shell-2) bash를 실행  docker exec -it sawtooth-shell-default bash   curl커맨드로 peer가 제대로 연결되었는지 확인해봅시다.  curl http://sawtooth-rest-api-default-0:8008/peers   data에 validator-1이 존재하는 것을 확인할 수 있습니다.  이는 validator-0(제네시스 블럭)과 validator-1이 연결되어 있다는 의미입니다.      xo게임 실행   두개의 validator 실행에 성공하였다면 xo게임생성을 통해 블럭이 쌓이는 모습을 확인해보겠습니다.  이전 문서를 참고해서 키 만들고 xo게임생성 ㄱㄱ xo create example --username a --url http://rest-api-0:8008     이전 문서에서는 단순히 rest-api:8008만 했지만 yaml 파일을 생성할때 validator0번의 rest-api가 rest-api-0으로 명명되었으므로 이렇게 작성해 주어야함    실행하게되면 shell-2에는 Response가 오게될 것    이전에 띄워놓았던 shell-1을 확인해보면 validator 1개를 쓸 때보다 많은양의 로그가 기록되어있는것을 확인할 수 있음. 두개의 validator 모두 검증작업을 진행하기 때문이다.     로그의 내용은 따로 설명하지 않을 것. 읽으면 자연스레 알게되는 내용★    두개의 validator 모두 게임이 정상적으로 생성된 것을 확인할 수 있음!      4. YAML파일 뜯어보기   validator     validator-0:                                      //제네시스 블럭     image: hyperledger/sawtooth-validator:1.0       //이미지 이름     container_name: sawtooth-validator-default-0    //컨테이너 이름     expose:                                         //사용할 포트       - 4004       - 8800     command: \"bash -c \\\"\\                           //제네시스블럭을 생성         sawadm keygen --force &amp;&amp; \\         sawset genesis \\           -k /etc/sawtooth/keys/validator.priv \\           -o config-genesis.batch &amp;&amp; \\         sawset proposal create \\           -k /etc/sawtooth/keys/validator.priv \\           sawtooth.consensus.algorithm=poet \\           sawtooth.poet.report_public_key_pem=\\           \\\\\\\"$$(cat /etc/sawtooth/simulator_rk_pub.pem)\\\\\\\" \\           sawtooth.poet.valid_enclave_measurements=$$(poet enclave measurement) \\           sawtooth.poet.valid_enclave_basenames=$$(poet enclave basename) \\           -o config.batch &amp;&amp; \\         poet registration create -k /etc/sawtooth/keys/validator.priv -o poet.batch &amp;&amp; \\         sawset proposal create \\           -k /etc/sawtooth/keys/validator.priv \\              sawtooth.poet.target_wait_time=5 \\              sawtooth.poet.initial_wait_time=25 \\              sawtooth.publisher.max_batches_per_block=100 \\           -o poet-settings.batch &amp;&amp; \\         sawadm genesis \\           config-genesis.batch config.batch poet.batch poet-settings.batch &amp;&amp; \\         sawtooth-validator -v \\                    //validator 설정           --bind network:tcp://eth0:8800 \\         //bind : 포트를 고정시킴           --bind component:tcp://eth0:4004 \\           --peering dynamic \\                      //동적으로 peer를 붙임           --endpoint tcp://validator-0:8800 \\      //작업이 실제로 수행되는 지점           --scheduler serial \\                     //스케줄링은 serial하게(병렬도 있음)           --network trust                          //신뢰하는 네트워크만     \\\"\"     environment:                                   //환경변수       PYTHONPATH: \"/project/sawtooth-core/consensus/poet/common:\\         /project/sawtooth-core/consensus/poet/simulator:\\         /project/sawtooth-core/consensus/poet/core\"     stop_signal: SIGKILL                          //종료는 ctrl+c    validator-1:                                    //제네시스 블럭에 붙을 1번노드        image: hyperledger/sawtooth-validator:1.0      container_name: sawtooth-validator-default-1     expose:       - 4004       - 8800     command: |                                    //제네시스 블럭과 달리 블럭을         bash -c \"                                   //생성할 필요가 없음!!!         sawadm keygen --force &amp;&amp; \\         sawtooth-validator -v \\             --bind network:tcp://eth0:8800 \\             --bind component:tcp://eth0:4004 \\             --peering dynamic \\             --endpoint tcp://validator-1:8800 \\             --seeds tcp://validator-0:8800 \\      //붙을 노드의 ip(로컬에서는 이름)             --scheduler serial \\             --network trust       \"     environment:       PYTHONPATH: \"/project/sawtooth-core/consensus/poet/common:\\         /project/sawtooth-core/consensus/poet/simulator:\\         /project/sawtooth-core/consensus/poet/core\"     stop_signal: SIGKILL   rest-api외 다른 이미지들    rest-api-0:                                      //validator에 붙일 이미지의 이름     image: hyperledger/sawtooth-rest-api:1.0     container_name: sawtooth-rest-api-default-0     expose:       - 4004       - 8008     command: |       bash -c \"         sawtooth-rest-api \\           --connect tcp://validator-0:4004 \\      //반드시 해당 블럭의 validator에 connect           --bind rest-api-0:8008\"     stop_signal: SIGKILL    rest-api-1:     image: hyperledger/sawtooth-rest-api:1.0     container_name: sawtooth-rest-api-default-1     expose:       - 4004       - 8008     command: |       bash -c \"         sawtooth-rest-api \\           --connect tcp://validator-1:4004 \\           --bind rest-api-1:8008\"     stop_signal: SIGKILL          ...    xo-tp-0:     image: hyperledger/sawtooth-xo-tp-python:1.0     container_name: sawtooth-xo-tp-python-default-0     expose:       - 4004     command: xo-tp-python -vv -C tcp://validator-0:4004     stop_signal: SIGKILL    xo-tp-1:     image: hyperledger/sawtooth-xo-tp-python:1.0     container_name: sawtooth-xo-tp-python-default-1     expose:       - 4004     command: xo-tp-python -vv -C tcp://validator-1:4004     stop_signal: SIGKILL         //나머지 이미지들도 비슷   5. 마치며   여러개의 validator를 로컬 서버안에서 다뤄보는 작업을 하였고, 다음 문서에서는 서로 다른 네트워크상에서 validator를 이어보는 작업을 해볼것      ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter05/",
        "teaser":null},{
        "title": "06.Connect multi validator in Remote network",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for windows(18.03.01-ce-win65)에서 다루며 os는 window 10 pro임   1. Overview  이번 문서에서는 서로다른 네트워크에서 validator를 연결해보도록 하겠습니다.   2. Prerequisites   이전문서에서는 validator 2개를 로컬환경에서 연결하는 작업을 했었음. 이번 문서의 작업을 제대로 이해하기 위해서는 이전문서를 꼭 읽어보고 오시기 바랍니당   먼저 제네시스블럭을 생성하는 YAML과 기타 validator의 YAML을 다운로드 받아주세요      이 문서는 포트를 다루고 있기 때문에 로컬환경에서 작업하던 이전 문서와 달리 예상치못한 네트워크 관련 문제가 (매우)많이 생길 수 있습니다.  실제로 매우매우매우 고생했기 때문에…몇가지 해결방법을 미리 기술합니다.          방화벽을 확인한다. 방화벽 고급설정의 인바운드 아웃바운드 규칙을 만들어줍시다.     yaml파일의 bind와 endpoint, seeds 그리고 connect 부분을 확인합니다.     사용하는 공유기 또는 컴퓨터의 환경에 따라서 컴퓨터 자체의 로컬ip와(자기 자신을 가리키는) 외부에서 자신을 가리키는 ip가 다를 수 있습니다. 이런 경우에는 yaml파일에서는 자기자신을 가리키는 로컬ip를 사용해야하고 외부에서 블럭의 내용을 볼 때는 외부ip를 사용합니다.     공유기를 사용하는 경우-&gt; 일부 공유기는 특정 포트를 막아놓는 경우가 있습니다. 포트포워딩으로 뚫어줍시다.     ssh키교환     다했는데 안된다 -&gt; 끄고 자면됨 -&gt; 행복      3. 일단 실행      genesis block이 있는 컴퓨터를 com-1, 기타 validator가 있는 컴퓨터를 com-2로 하겠습니다.    com-1과 com-2에서 다운받은 yaml파일을 실행해봅시다. genesis block을 생성하는 com-1에서 먼저 실행하고 그다음 com-2의 yaml파일을 실행해봅시다.  docker-compose -f sawtooth-default-poet.yaml up  yaml파일에 미리 기록해두었던 이미지들이 실행될겁니다.   com-1에서 실행한 결과:    yaml파일에 기술되어있던 이미지들이 handler에 의해 validator에 붙게되고 chain heead를 생성한 뒤, 블럭의 top을 쌓게 됩니다. 그리고 다른 peer나 트랜잭션이 올 때까지 대기하게 됩니다.   com-1의 ip:8008/blocks를 주소창에 쳐보면 블럭이 생성된 모습을 확인할 수 있습니다.     com-2에서 실행한 결과(비정상):    이 뒤로 아무것도 뜨지 않는다면 제대로 연결되지 않았음을 의미합니다.  원인은 3가지정도가 있는데,     연결하려는 validator의 ip가 정확하지 않다.   연결하고자하는 컴퓨터의 포트나 내 컴퓨터의 포트가 제대로 열려있지 않다.   연결하고자하는 validator의 준비가 되지 않았다.  이 경우는 com-2를 먼저 실행하고 com-1을 나중에 실행하는 경우가 되겠네요.   제대로 연결되지 않는다면 블럭이 제대로 생성되지 않아,  com-2 ip:8008/blocks 을 주소에 쳤을 경우 이런 화면이 뜨게 됩니다.     com-2에서 실행한 결과(정상):    위의 결과이후에 block을 building하기 시작합니다. 이러면 com-1과 연결이 성공했음을 알 수 있습니다.   com-1의 화면을 잠깐 보면    같은 화면처럼 보이겠지만 두 사진은 서로 다른 네트워크에서 작업한 것입니다. 빨간 밑줄을 친 부분을 보면 block의 검증을 진행하고 검증이 완료되면 블럭을 업데이트하는 모습을 볼 수 있습니다.   그럼 이제 com-2 ip:8008/blocks 을 주소에 쳐보겠습니다.    블럭의 길이가 1 증가된 모습을 확인할 수 있습니다. com-1의 blocks도 확인해보면 똑같은 블럭을 갖고 있는 모습을 확인할 수 있습니다.   4. YAML파일 뜯어보기   validator  기본적으로 이전문서의 yaml구성과 비슷합니다. 하지만 정확한 ip를 명시해줘야 한다는 점을 잊으면 안됩니다.    validator-0:                                       //com-1의 validator(genesis)     image: hyperledger/sawtooth-validator:1.0     container_name: sawtooth-validator-default-0     expose:       - 4004       - 8800     ports:       - \"8800:8800\"     command: \"bash -c \\\"\\         sawadm keygen --force &amp;&amp; \\         sawset genesis \\           -k /etc/sawtooth/keys/validator.priv \\           -o config-genesis.batch &amp;&amp; \\         sawset proposal create \\           -k /etc/sawtooth/keys/validator.priv \\           sawtooth.consensus.algorithm=poet \\           sawtooth.poet.report_public_key_pem=\\           \\\\\\\"$$(cat /etc/sawtooth/simulator_rk_pub.pem)\\\\\\\" \\           sawtooth.poet.valid_enclave_measurements=$$(poet enclave measurement) \\           sawtooth.poet.valid_enclave_basenames=$$(poet enclave basename) \\           -o config.batch &amp;&amp; \\         poet registration create -k /etc/sawtooth/keys/validator.priv -o poet.batch &amp;&amp; \\         sawset proposal create \\           -k /etc/sawtooth/keys/validator.priv \\              sawtooth.poet.target_wait_time=5 \\              sawtooth.poet.initial_wait_time=25 \\              sawtooth.publisher.max_batches_per_block=100 \\           -o poet-settings.batch &amp;&amp; \\         sawadm genesis \\           config-genesis.batch config.batch poet.batch poet-settings.batch &amp;&amp; \\         sawtooth-validator -v \\           --bind network:tcp://eth0:8800 \\           --bind component:tcp://eth0:4004 \\           --peering dynamic \\           --endpoint tcp://--.--.--.--:8800         //com-1의 ip주소     \\\"\"     environment:       PYTHONPATH: \"/project/sawtooth-core/consensus/poet/common:\\         /project/sawtooth-core/consensus/poet/simulator:\\         /project/sawtooth-core/consensus/poet/core\"     stop_signal: SIGKILL    validator-1:                                        //com-2의 validator     image: hyperledger/sawtooth-validator:1.0     container_name: sawtooth-validator-default-1     expose:       - 4004       - 8800     ports:       - \"8800:8800\"     command: |       bash -c \"         sawadm keygen --force &amp;&amp; \\         sawtooth-validator -v \\             --bind network:tcp://eth0:8800 \\             --bind component:tcp://eth0:4004 \\             --peering dynamic \\             --endpoint tcp://--.--.--.--:8800 \\      //com-2의 ip주소             --seeds tcp://--.--.--.--:8800 \\        //com-1의 ip주소             --scheduler serial \\             --network trust       \"     environment:       PYTHONPATH: \"/project/sawtooth-core/consensus/poet/common:\\         /project/sawtooth-core/consensus/poet/simulator:\\         /project/sawtooth-core/consensus/poet/core\"     stop_signal: SIGKILL  얘네 외에는 똑같음. endpoint에 주의!   5. 마치며   validator를 서로다른 네트워크 안에서 이어보는 작업을 하였고, 다음 문서에서는 커스텀이미지(processor)를 구축한 뒤, 실제로 validator에 붙여보는 작업을 할 것!      ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter06/",
        "teaser":null},{
        "title": "07.Make Custom Processor and Connect to Validator",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for windows(18.03.01-ce-win65)에서 다루며 os는 window 10 pro임   1. Overview  이번 문서에서는 커스텀 프로세서를 만들어 validator에 연결해보도록 하겠습니다. 빠른 진행을 위해 xo게임을 수정해서 붙여보겠습니다.   2. Prerequisites   이전문서에서는 validator들을 서로 다른 네트워크에서 이어보는 작업을 진행했습니다. 이번 문서의 작업을 제대로 이해하기 위해서는 이전문서를 꼭 읽어보고 오시기 바랍니당   먼저 NEWxo.jar와 Dockerfile그리고 YAML파일을 다운로드 받아주세요   3. 일단 실행   다운로드 받은 폴더에서 yaml 파일을 실행해봅시다.  docker-compose -f sawtooth-default-poet.yaml up     jar파일을 build해서 이미지로 만드는 과정입니다. 이 과정을 통해서 커스텀 프로세서를 구현하고 validator에 붙여 sawtooth 네트워크를 구성할 수 있습니다.   새롭게 추가한 new-xoGAME의 달라진 기능은 별거없습니다. X표시가 A표시로 바뀐것 뿐입니다.    xo커맨드를 사용하여 게임을 만들고 각 플레이어끼리 게임을 진행한 뒤, 게임판을 show하니 X표시가 A표시로 바뀐 것을 확인할 수 있습니다.   4. JAVA to Jar   자바프로그램은 sawtooth sdk예제로 나온 xo transaction을 사용하였고, X를 저장하는 부분의 코드를 A로 바꿨습니다.   자바프로그램을 Jar파일로 바꾸는 과정은 인터넷을 참고 ㄱㄱ  또한 자바프로그램이 제대로 실행되지 않는 파일이라면 당연히 Jar파일을 쓸수없습니당   5. Dockerfile 뜯어보기   FROM anapsix/alpine-java                      //자바 MAINTAINER new-xoGAME:1.0                     //이름:버전 COPY new-xoGAME.jar /home/new-xoGAME.jar      //현재위치폴더의 jar를 docker내 home폴더로 이동시킴 CMD [\"java\",\"-cp\",\"/home/new-xoGAME.jar\", \"src.sawtooth.examples.xo.XoTransactionProcessor\",\"tcp://validator-0:4004\"] //java, -cp, jar파일이름.jar, jar파일내 main이 존재하는 class이름, main의 argument   main의 argument를 집어넣는 부분은 yaml파일의    command부분과 형식이 같습니다.  이 부분은 현재 실행되고있는 validator에 붙이는 부분입니다.   6. YAML파일 뜯어보기   새로 추가된 new-xoGAME  기본적으로 이전문서의 yaml구성과 비슷합니다. dockerfile을 통해 이미지를 생성하는 방법은 주의깊게 봐주시기 바랍니다.    new-xogame-1:     build:                                    //빌드할것       context: .       dockerfile: ./Dockerfile                //현재위치 폴더의 도커파일을 불러옴     image: sawtooth-new-xogame:1.0     container_name: new-xogame     expose:       - 4004     ports:       - \"4004:4004\"     stop_signal: SIGKILL  외에는 똑같음.   5. 마치며   생각보다 자료가 정말 없어서 정말 고생했던것 같습니다. 최대한 쉽게 커스텀 프로세서를 추가하는 방법을 다뤄봤습니다. 이제는 원하는 작업을 만들어서 validator에 붙이기만 하면 내가원하는 블럭체인 네트워크 완-성!      ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter07/",
        "teaser":null},{
        "title": "08.Configuring Permission",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for ubuntu(18.03.01-ce)에서 다루며 os는 ubuntu-18.04 LTS임   1. Overview  이번 문서에서는 Transaction과 Batch의 권한 생성 및 설정에 대해서 다뤄보겠습니다.   2. Prerequisites   이번 문서부터는 os를 ubuntu환경으로 바꾸었습니다. 도커기반인건 바뀌지 않았지만 core에서 코드를 내려받아서 그대로 실행할것이기 때문에 참고하시기 바랍니다.   먼저 sawtooth-core를 클론해주세요   폴더 만들고 폴더안에서 다음 커맨드 입력  git clone https://github.com/hyperledger/sawtooth-core   3. 일단 실행하기 전에      처음엔 윈도우 환경 하에서 sawtooth-core를 올려보려고 했지만 개발자체가 리눅스 환경하에서 만들어진것같아서 파이썬 소스코드를 실행할 때, 인코딩문제가 좀 있는거 같더군요.     /usr/bin/env: ‘python3\\r’: No such file or directory      위와 같은 오류에 대해 몇가지 해결방법이 있긴 하지만 생각보다 까다롭고 귀찮아서 os를 리눅스로 바꿨습니다.  윈도우 유저분들은 VirtualBox나 Hyper-V와 같은 가상머신을 사용하는 것을 추천합니다.       linux에서의 도커설정도 윈도우와 마찬가지입니다. 하나 참고해야할 점은 docker-compose 버전이 최신버전이어야 합니다. 제가 core를 돌렸을 때의 버전은 docker-compose version 1.22.0, build f46880fe 입니다.    다운로드 받은 폴더에 들어가서 docker-compose.yaml 파일을 열어봅시다.  vim docker-compose.yaml   현재 sawtooth-core내의 docker-compose.yaml파일 안에는 identity에 대한 이미지 설정이 들어있지 않습니다.     대신 devmode-rust라는게 들어가있는데, 이것까지 포함해서 yaml파일을 실행시켜 policy 설정 및 identity관련 커맨드를 입력하면 devmode-rust 프로세서는 죽더군요… poet-engine이라는 이미지는 실행만하면 죽던데 사실 이 두개의 프로세서의 역할과 왜 죽는지는 해결하지 못했습니다. 추후 알아내면 업데이트하겠습니다.    우선 devmode-rust와 poet-engine를 제외하고 sawtooth-identity를 추가해서 실행시켜보도록 하겠습니다.    identity-tp:     build:       context: .       dockerfile: families/identity/Dockerfile      image: sawtooth-identity-local:${ISOLATION_ID}     volumes:       - ./:/project/sawtooth-core     container_name: sawtooth-identity-local     depends_on:       - validator     command: |       bash -c \"         bin/protogen         cd families/identity         python3 setup.py clean --all         python3 setup.py build         identity-tp -vv -C tcp://validator:4004       \"     stop_signal: SIGKILL  위와 같은 코드를 docker-compose.yaml파일에 추가시킨 뒤, yaml파일을 돌려봅시다.   docker-compose up     docker-compose에 따로 파일이름을 기재하지 않는 이유는 파일이름이 docker-compose.yaml이기 때문입니다. 만약 파일이름이 a.yaml이라면    docker-compose -f a.yaml up       위와 같이 나오겠죠.    4. 기다림기다림기다림   파일이 많아서 그런지 아주 오래 기다려야합니다.   5. authorized_keys  블록체인 상에서 다른 transactor들의 권한을 관리할 수 있는 transactor는 (아무런 설정을 하지 않았을 시) genesis block을 서명한 transactor입니다. genesis block을 서명한 transactor는 도커파일을 보면 알 수 있는데,      sawadm keygen            //  etc/sawtooth/keys/validator.priv와 pub키생성     sawtooth keygen          //  root/.sawtooth/keys/root.priv와 pub키생성     sawset genesis           //root.priv로 서명     sawadm genesis config-genesis.batch     sawtooth-validator -v \\         --endpoint tcp://localhost:8800 \\         --bind component:tcp://eth0:4004 \\         --bind network:tcp://eth0:8800 \\         --bind consensus:tcp://eth0:5050 \\  위 코드는 root의 비밀키로 genesis블록을 서명하여 생성합니다.     위 사진은 root의 비밀키와 공개키입니다. 다음 사진은 genesis block인데 signer의 공개키가 root의 공개키와 같다는 것을 볼 수 있습니다.     또한 다음사진은 genesis block에 담긴 payload를 Base64 디코딩한 사진입니다.     sawtooth.settings.vote.authorized_keys는 다음과 같은 의미를 지니고 있습니다.        쉽게 얘기해서 sawtooth의 설정을 변경할 때 authorized_keys가 하나일경우 인증받은 키 하나만 동의하면 설정이 변경되고, authorized_keys가 여러개일 경우, 일정 퍼센트 이상이 동의해야 설정을 변경할 수 있습니다.    즉 root의 공개키는 sawtooth의 설정을 변경할 수 있는 키가 되었다는 것이고, 이제 Transactor와 Validator의 권한설정을 위해 필요한 권한을 원하는 키에 할당해 주어야 합니다.   6. allowed_keys  identity 프로세서를 통해 권한을 설정할 수 있는 권한을 가진 키는  sawset proposal create sawtooth.identity.allowed_keys=&lt;public key&gt;  를 통해 설정할 수 있습니다.   sawtooth에서 지정할 수 있는 정책은 두가지입니다.     PERMIT_KEY : 허가   DENY_KEY : 거절    현재 sawtooth에서 설정할 수 있는 Transactor의 role은 5개로 다음과 같습니다.      default:    기본 설정은 “PERMIT_KEY *” 임. 특정 role을 지정해주지 않았다면 default가 됨.     transactor:    transaction과 batch를 서명할 수 있는 최상위 role. 만약 transactor에 DENY_KEY를 준다면 transactor와 batch에 관한 요청 모두 거절됨.     transactor.transaction_signer:    transaction의 서명에 관한 role     transactor.transaction_signer.{tp_name}:    특정 transaction processor(Family)의 서명에 관한 role     transactor.batch_signer:    batch의 서명에 관한 role     role에 정책을 적용할 때는 다음과 같이 작성합니다.  transactor.SUB_ROLE = POLICY_NAME      예시)  sawtooth identity policy create policy_1 “DENY_KEY *”  sawtooth identity role create transactor policy_1     모든 키에대해 DENY하는 정책인 policy_1을 만들고, policy_1을 transaction과 batch를 서명할 수 있는 최상위 role에 부여합니다.  이러면 모든 키는 transaction과 batch에 서명할 수 없게 됩니다.(본인포함)    정말 주의해야할 점은, policy는 순차적으로 적용된다는 것입니다. (if-else를 생각하면 이해가 쉬움.)   예시1)     a,b,c의 키쌍이 있음   a,b,c의 를 이용해 정책을 만듬   DENY_KEY a =&gt; transactor에 적용(위 예시참고)   우리 모두의 생각: a만 transactor에 관한 권한이 DENY되겠지, b와 c는 PERMIT일거야   현실: 전부 DENY됨   예시2)     a,b,c의 키쌍이 있음   각 공개키를 사용해 정책을 만들것   DENY_KEY a, PERMIT_KEY *, DENY_KEY b 의 정책을 만든 뒤   DENY_KEY a  PERMIT_KEY *  DENY_KEY b  의 순으로 transactor에 정책 적용   예상: a와 b는 DENY되고 c는 PERMIT될거야!   현실: a만 DENY되고 b와 c는 PERMIT됨   위의 두 예시를 잘 보면 순서대로 정책이 적용되는 것을 볼 수 있습니다. switch-case처럼 해당되는 정책에 빨려들어가서 break가 걸려서 switch문을 빠져나오는것과 같습니다.   예시2를 실제로 실행해봅시다. 이전에 authorized_keys로 설정된 키로 allowed_keys를 설정해줄겁니다.  sawset proposal create sawtooth.identity.allowed_keys=038d91da5969ac3958649a25b27165c78c1ee46a3bc93aecea660a47a843bd5b6d --url http://rest-api:8008  현재 문서에서는 authorized_keys는 genesis 블록을 서명한 root입니다.      sawset를 통해 제안하는 커맨드의 default 키설정은 root/.sawtooth/keys의 root.priv입니다. 따라서 위와 똑같은 커맨드를 작성하려면 root/.sawtooth/keys의 root가 authorized되어야하며 커맨드를 입력하는 폴더가 root/.sawtooth/keys 안이어야 합니다.     만약, root.priv가 아닌 다른 키로 설정하려면 다음과 같이 -k 옵션을 달아주면 됩니다.    sawset proposal create sawtooth.identity.allowed_keys=&lt;공개키&gt; -k 설정하려고하는 다른키의 위치/다른키.priv --url ...      sawtooth keygen a ...  a,b,c의 키를 생성한 뒤, 예제2와같이 정책을 설정   sawtooth identity policy create p1 \"DENY_KEY &lt;a공개키&gt;\" \"PERMIT_KEY *\" \"DENY_KEY &lt;b공개키&gt;\" --url http://rest-api:8008     sawtooth identity policy list --url http://rest-api:8008  위와같은 커맨드를 통해 현재 만들어진 정책들의 list를 볼 수 있습니다.     예제2와같이 transactor에 정책을 설정해주고  sawtooth identity role list --url http://rest-api:8008  위와같은 커맨드를 통해 현재 설정된 role의 list를 볼 수 있습니다.   그럼 테스트로 xo게임을 create하는 트랜잭션을 만들어 보겠습니다. 예제2의 예상대로면 a와 b는 트랜잭션이 거절되어야하고 c만 xo게임이 만들어져야 합니다.     하지만 a의 트랜잭션만 거절되고 나머지 b와 c는 제대로 트랜잭션이 들어간 것을 확인할 수 있습니다.     현재 sawtooth에서 설정할 수 있는 Validator의 role은 2개로 다음과 같습니다.      network:  peer를 붙이는(현재 validator에 붙으려는 요청)요청이 올 때, 그 요청을 보내는 public key가 policy에 의하여 거절되었다면 이 요청은 거절되고 AuthorizationViolation 메세지가 리턴되고 커넥션은 끊어지게 됩니다.     network.consensus:  validator가 새로운 블록을 만들자는 GossipMessage를 받았을 때, 그 요청을 보내는 public key가 policy에 의해 거절되었다면 요청거절-&gt;AuthorizationViolation 메세지가 리턴되고 커넥션 종료     7. 마치며   공식doc를 열심히 봅시다^^….      ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter08/",
        "teaser":null},{
        "title": "09.Building and Submitting Transactions with js",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for ubuntu(18.03.01-ce)에서 다루며 os는 ubuntu-18.04 LTS임   1. Overview  이번 문서에서는 자바스크립트 코드로 트랜잭션을 만들고, validator에 제출해보도록 하겠습니다.     node.js사용    2. Prerequisites   이전 문서에서 했던 과정을 그대로 따라해주시고 docker-compose커맨드로 sawtooth를 실행시켜주시기 바랍니다.   같은 폴더 안에 있는 package.json과 compile_protobuf.js파일, protobuf폴더와 protos폴더를 클론받아 프로젝트에 추가시켜주세요.   3. Install Package   cmd창에서 다음 커맨드를 통해 패키지를 설치합니다.  npm install  패키지를 설치하고 나면 프로젝트 구조는 다음과 같이 구성됩니다.     node_moudules에는 package.json에 기재되어있던 의존모듈이 추가되고 scripts의 prepublish를 통해 compile_protobuf.js가 컴파일되고 payload를 인코딩할 수 있는 protobuf_bundle.json이 추가됩니다.   4. protobuf_bundle.json   protobuf_bundle.json파일은 compile_protobuf.js파일을 컴파일함으로써 protos폴더 안의 proto파일을 json형식으로 나타낸 것입니다. 이를 통해 Payload가 어떤식으로 구성되어야하는지를 알 수 있게됩니다.   proto 파일에 대한 정보는 여기   5. Payload 구성      Payload를 구성함에 있어 가장 주의깊게 봐야할 부분은 Encoding하는 부분입니다. 모든 트랜잭션 패밀리에서 payload를 parsing하는 방법이 다르기 때문에 보내는 방법도 각양각색입니다.  반드시 참고해야할 트랜잭션 패밀리의 핸들러 소스코드와 proto파일을 읽어보셔야합니다.    5.1 Intkey  intkey 트랜잭션 패밀리는 payload를 CBOR로 encoding하고 json형식으로 작성해야합니다.   const cbor = require('cbor') const payload = {     Verb: 'set',     Name: 'foo',     Value: 42 } const payloadBytes = cbor.encode(payload)   5.2 Xo  Xo 트랜잭션 패밀리는 payload를 작성하는 방법이 Intkey와는 사뭇 다릅니다. payload를 핸들링하는 소스코드를 참고하면서 봐주세요.  class XoPayload:      def __init__(self, payload):         try:             # The payload is csv utf-8 encoded string             name, action, space = payload.decode().split(\",\")         except ValueError:             raise InvalidTransaction(\"Invalid payload serialization\")     ...  xo트랜잭션의 payload를 핸들링하는 소스코드의 일부입니다. try문 안을 보면 name, action, space의 순서대로 “,“를 기준으로 parsing하고 있습니다.   xo 트랜잭션의 payload를 구성할 때는 json형식으로 구성한다면 InvalidTransaction 에러가 뜰 수 밖에 없습니다.      const payload = \"game1,create,\";     const payloadBytes = cbor.encode(payload);  위와 같이 페이로드를 구성하면 됩니다.   5.3 Identity   세 번째 예시는 Identity 트랜잭션 패밀리입니다. 제가 예시를 들어볼 트랜잭션은 policy를 생성하는 트랜잭션입니다.      Identity 트랜잭션을 만드려면 npm install하기전에 protos 폴더에 identities.proto 파일이 존재해야합니다.  sawtooth-core의 protos폴더에는 identities.proto파일이 존재하지 않고, 여기에 있으니 참고하시기 바랍니다. 현재 문서의 protos 폴더에는 identities.proto를 추가시켜놨습니다.       단순히 require(“protobuf”)를 하게 되면, node_modules를 참조하게 됩니다. 하지만 우리는 identities.proto를 임의로 추가시켜 protobuf_bundle파일을 생성했으니 node_modules가 아닌 로컬의 protobuf파일을 참조하게 해야합니다.     따라서 이와같이 작성하여야 합니다.    const {Policy,IdentityPayload,TransactionHeader,Transaction,BatchHeader,Batch,BatchList} = require(\"../protobuf\");       protobuf_bundle.json 파일로 가서 payload를 만들기 위한 양식을 찾아봅시다. Policy나 Role을 세팅하기 위한 json 포맷은 다음과 같습니다.       \"IdentityPayload\": {       \"fields\": {         \"type\": {           \"type\": \"IdentityType\",           \"id\": 1         },         \"data\": {           \"type\": \"bytes\",           \"id\": 2         }       },       \"nested\": {         \"IdentityType\": {           \"values\": {             \"IDENTITY_TYPE_UNSET\": 0,             \"POLICY\": 1,             \"ROLE\": 2           }         }       }     },  먼저 최종적으로 IdentityPayload에 들어가야할 내용은 type과 data입니다. type은 IdentityType을 참고하고 있고, IdentityType은 하단의 nested안에서 확인할 수 있습니다.  제가 예시로 들 내용은 policy를 세팅하는 것이니 type은 1이 될 것입니다.   다음으로는 data입니다. data에는 policy에 세팅할 정보가 들어가게 될 것입니다.      \"Policy\": {       \"fields\": {         \"name\": {           \"type\": \"string\",           \"id\": 1         },         \"entries\": {           \"rule\": \"repeated\",           \"type\": \"Entry\",           \"id\": 2         }       },       \"nested\": {         \"EntryType\": {           \"values\": {             \"ENTRY_TYPE_UNSET\": 0,             \"PERMIT_KEY\": 1,             \"DENY_KEY\": 2           }         },         \"Entry\": {           \"fields\": {             \"type\": {               \"type\": \"EntryType\",               \"id\": 1             },             \"key\": {               \"type\": \"string\",               \"id\": 2             }           }         }       }     },  Policy는 name과 entries가 필요합니다. name은 String형, entries는 Entry형이고 반복될수있습니다.   다음과 같은 커맨드는  $ sawtooth identity policy create p1_name \"PERMIT_KEY *\"    이렇게 구성될 수 있습니다.      const policyBytes = Policy.encode({         name: \"p1_name\",         entries: [             {                 type: 1,   //PERMIT_KEY                 key: \"*\"             }         ]     }).finish();      const payloadBytes = IdentityPayload.encode({         type : 1,          //policy         data : policyBytes     }).finish();  CBOR을 사용하지 않고, protocol buffer의 encode를 사용하고 있습니다.      identity는 트랜잭션을 보낼 때 allowed_key로 정해진 key만 sign이 가능합니다.    6. Signer   공식 문서의 예시에서는 랜덤으로 privateKey를 생성하여 트랜잭션과 배치에 서명하게 되어있습니다.  특정 privateKey로 서명하고 싶다면 다음과 같이 하면 됩니다.           const context = createContext(\"secp256k1\"); //암호화 컨텍스트                  const privateKey = Secp256k1PrivateKey.fromHex(\"8a0d61af0a9518bcf4d60f013edc5da6876fcd4dad9ee0f3a832a0c67122faae\");         const signer = new CryptoFactory(context).newSigner(privateKey);   7. Transaction Header  트랜잭션의 헤더는 다음과 같이 작성할 수 있습니다.      const transactionHeaderBytes = TransactionHeader.encode({         familyName: \"sawtooth_identity\",      //보내려는 트랜잭션의 패밀리 네임         familyVersion: \"1.0\",         inputs: [\"000000\", \"00001d\"],         //input : read from         outputs: [\"00001d\"],                  //output : write to         test: signer.getPublicKey(),         signerPublicKey: signer.getPublicKey(privateKey).asHex(),         // In this example, we're signing the batch with the same private key,         // but the batch can be signed by another party, in which case, the         // public key will need to be associated with that key.         batcherPublicKey: signer.getPublicKey(privateKey).asHex(),         // In this example, there are no dependencies.  This list should include         // an previous transaction header signatures that must be applied for         // this transaction to successfully commit.         // For example,         // dependencies:['540a6803971d1880ec73a96cb97815a95d374cbad5d865925e5aa0432fcf1931539afe10310c122c5eaae15df61236079abbf4f258889359c4d175516934484a'],         dependencies: [],         payloadSha512: createHash(\"sha512\").update(payloadBytes).digest(\"hex\")     }).finish();   input과 output에 관한 정보는 여기의 line 49처럼 define된 변수가 있거나 공식문서의 트랜잭션패밀리를 다룬 부분의 Addressing을 확인하면 됩니다.     만약 input과 output을 틀리게 적었다면 위와같은 오류가 발생합니다.   이 뒤의 내용은 공식문서의 예시와 같으니 참고하시면 됩니다.   8. 마치며   수고하셧읍니다^^7 점점 새로 공부해야하는 내용이 많아지네요. 다음 문서는 뭐로 작성하면 좋을지 고민중..      ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter09/",
        "teaser":null},{
        "title": "10.Using Grafana & InfluxDB in Sawtooth",
        "excerpt":"이 문서는 hyperledger sawtooth 1.0.4을 docker for ubuntu(18.03.01-ce)에서 다루며 os는 ubuntu-18.04 LTS임   1. Overview  이번 문서에서는 Grafana를 사용해 sawtooth의 모니터링을 할 수 있게 해보겠습니다.   2. Prerequisites   sawtooth-core의 클론   3. Set up InfluxDB   다음 커맨드를 통해 Docker Hub로부터 이미지를 받습니다.  $ docker pull influxdb   다음으로는 로컬파일시스템에 InfluxDB의 저장공간을 만들어줘야 합니다.  $ sudo mkdir /var/lib/influx-data   폴더까지 만들어줬으면 도커에서 실행시켜봅시다!  $ docker run -d -p 8086:8086 -v /var/lib/influx-data:/var/lib/influxdb \\  -e INFLUXDB_DB=metrics -e INFLUXDB_HTTP_AUTH_ENABLED=true \\  -e INFLUXDB_ADMIN_USER=admin -e INFLUXDB_ADMIN_PASSWORD='{admin-pw}' \\  -e INFLUXDB_USER=lrdata -e INFLUXDB_USER_PASSWORD='{lrdata-pw}' \\  --name sawtooth-stats-influxdb influxdb  INFLUXDB_DB: DB이름  INFLUXDB_HTTP_AUTH_ENABLED: DB에 접근하기위한 인증절차   INFLUXDB_ADMIN_USER &amp; INFLUXDB_ADMIN_PASSWORD: 관리자계정  INFLUXDB_USER &amp; INFLUXDB_USER_PASSWORD: 일반계정      ** INFLUXDB_HTTP_AUTH_ENABLED에 관하여…  이게 로컬에서 할 때는 별 문제없이 작동하다가 원격으로 서버에 접근하려고 할때 인증메세지가 뜨는데 저는 뭘 넣어도 인증이 안됬어요… (*서버의 슈퍼계정, 할당받은 서버계정, influxDB의 관리자계정, influxDB의 유저계정)  그래서 이 속성은 빼고 진행을 했습니다. 혹시 이 문제에 대해서 뭔가 아시거나 해결하신분은 메일주세오…  sygy0509@naver.com         4. Install and Configure Grafana   sawtooth-core에 포함된 Grafana Docker이미지를 찾고 빌드합니다.   $ cd sawtooth-core/docker  $ docker build . -f grafana/sawtooth-stats-grafana \\  -t sawtooth-stats-grafana   다음은 Grafana를 도커에서 실행!  $ docker run -d -p 3000:3000 --name sawtooth-stats-grafana \\  sawtooth-stats-grafana   실행시켰다면 그라파나를 실행시킨 호스트의 주소:포트3000 (http://{host}:3000)으로 접속해봅시다!     초기 관리자 계정인 id: admin, pwd: admin으로 로그인이 가능합니다.  (*관리자 계정의 비밀번호를 바꾸는건 기본!)   다음으로 Grafana에 아까 실행시켰던 InfluxDB를 연동시켜야 합니다.  좌측상단 아이콘을 누른 뒤 “Data Sources”클릭 -&gt; “Metrics”클릭하시면 다음과 같은 화면이 뜹니다.      HTTP Settings-&gt;URL: influxDB가 실행되는 호스트와 포트(8086)  InfluxDB Details-&gt;Database: influxDB의 이름  InfluxDB Details-&gt;userInfo: influxDB의 유저정보(없어도됨)  다음과 같이 설정해 주시고 Save&amp;Test 버튼을 클릭하면 연동이 성공하게 됩니다.   5. Configure the Sawtooth Validator&amp;REST API for Grafana   이제 Grafana와 InfluxDB의 연동이 성공하였으니 Sawtooth네트워크와 연동해야합니다.     공식문서에서는 docker가 아닌 우분투위에서 sawtooth네트워크를 실행하기 때문에 toml파일을 수정하는 방법을 설명하고 있습니다. 저는 docker위에서 sawtooth를 실행시키므로 yaml파일을 수정하는 방법을 소개하겠습니다.    실행시킬 sawtooth네트워크의 docker-compose.yaml파일을 수정해봅시다.   먼저 validator부분을 봅시다.    validator:     build:       context: .       dockerfile: validator/Dockerfile     image: sawtooth-validator-local:${ISOLATION_ID}     volumes:       - ./:/project/sawtooth-core     container_name: sawtooth-validator-local     expose:       - 4004       - 8008       - 8086     ports:       - \"4004:4004\"     # start the validator with an empty genesis batch     command: |       bash -c \"         bin/protogen         cd validator         python3 setup.py clean --all         python3 setup.py build         mkdir -p bin         mkdir -p lib         cargo build --release         cp ./target/release/sawtooth-validator bin/sawtooth-validator         cp ./target/release/libsawtooth_validator.so lib/libsawtooth_validator.so         sawadm keygen         sawtooth keygen         sawset genesis         sawadm genesis config-genesis.batch         sawtooth-validator -v \\             --endpoint tcp://localhost:8800 \\             --bind component:tcp://eth0:4004 \\             --bind network:tcp://eth0:8800 \\             --bind consensus:tcp://eth0:5050        \"     stop_signal: SIGKILL  제가 사용하고 있는 yaml파일의 validator입니다. 다른부분은 필요없고 이 부분을 수정하시면 됩니다.  sawtooth-validator -v \\             --endpoint tcp://localhost:8800 \\             --bind component:tcp://eth0:4004 \\             --bind network:tcp://eth0:8800 \\             --bind consensus:tcp://eth0:5050 \\             --opentsdb-url http://{influxdb}:8086 \\             --opentsdb-db metrics  --opentsdb-url: influxDB가 실행되고 있는 호스트의 주소:포트  --opentsdb-db : influxDB의 이름   다음은 REST-API부분   rest-api:     build:       context: .       dockerfile: rest_api/Dockerfile     image: sawtooth-rest-api-local:${ISOLATION_ID}     volumes:       - ./:/project/sawtooth-core     container_name: sawtooth-rest-api-local     ports:       - \"8008:8008\"     depends_on:       - validator     command: |       bash -c \"         bin/protogen         cd rest_api         python3 setup.py clean --all         python3 setup.py build         sawtooth-rest-api -v --connect tcp://validator:4004 --bind rest-api:8008        \"     stop_signal: SIGKILL   validator와 마찬가지로 rest-api의 커맨드를 수정해주시면 됩니다.   sawtooth-rest-api -v --connect tcp://validator:4004 --bind rest-api:8008 --opentsdb-url http://{influxDB}:8086 --opentsdb-db metrics      ** 일부 속성 문제에 대하여…  공식문서의 toml파일을 수정하는 부분을 보시면 속성이 두 개가 더있습니다. opentsdb_username이랑 opentsdb_password인데요.. sawtooth개발자분들이 의도적으로 빼두신건지 아니면 까묵은건지 sawtooth-validator의 CLI에는 저 두 속성이 존재하지 않습니다.  물론 이 둘을 없애도 잘 돌아가긴 합니다. 저는 빼고 진행했습니다.    –&gt;수정 후, sawtooth네트워크 실행!   6. Configure Telegraf   Telegraf는 InfluxDB의 제작사에서 제작한 시스템 모니터링 및 지표 수집 에이전트입니다. 간단히 말해서 sawtooth네트워크와 os의 여러 정보를 InfluxDB로 보내주는 역할을 합니다.   그럼 Telegraf를 다운로드 받아봅시다.  $ curl -sL https://repos.influxdata.com/influxdb.key |  sudo apt-key add - $ sudo apt-add-repository \"deb https://repos.influxdata.com/ubuntu xenial stable\" $ sudo apt-get update $ sudo apt-get install telegraf   다운로드가 끝났다면 InfluxDB와 연결하기 위해 Telegraf의 속성을 수정하여야 합니다.  $ sudo vim /etc/telegraf/telegraf.conf  파일을 열어서 OUTPUT PLUGINS을 찾은다음 다음 속성을 추가합시다.  # Configuration for sending metrics to InfluxDB [[outputs.influxdb]]   urls = [\"http://{influxDB host}:8086\"]   database = \"metrics\"  이후, telegraf 명령어를 입력하면 준비완료!  $ telegraf   7. Grafana   7.1 Graph  sawtooth네트워크를 올려봅시다. 별 문제가 없다면 다음과 같은 화면이 뜰 것입니다.    하단에 빨간색으로 표시한 줄은 오류가 아니에요!  저는 Bad Request가 떠서 제대로 연결이 되지 않았나 해서 온갖 삽질을 했지만^^…   validator에서 전달되는 값이 없어서 그런것 같습니다.   그럼 바로 xo게임을 시험삼아 실행해서 게임을 진행해봅시다. 참고   트랜잭션을 발생시키고 블록이 생성된 것을 확인했으면 Grafana페이지로 가서 Dashboard를 확인해봅시다!    네트워크를 올리고 얼마 시간이 지나지 않아서 그래프가 많이 빈약하지만 그래프의 생성유무를 확인할 수 있습니다.   또한, 그래프에 마우스를 올려놓으면 세부 사항도 확인할 수 있습니다.     실시간 모니터링(Auto-Refresh)은 Dashboard 우측 상단 시계를 클릭해서 설정할 수 있습니다.    5초로 설정하면 5초마다 그래프가 새로고침됩니다.   7.2 User   Dashboard를 볼 수 있는 유저를 추가하는 방법입니다.  좌측상단 똥글뱅이문양을 누르고 Admin-&gt;Grobal Users-&gt;Add new User    정보를 기입하고 생성을 누르면 다음과 같이 유저계정을 만들 수 있습니다.     생성한 유저의 권한 관리는 우측의 Edit버튼을 통해 관리할 수 있습니다.   8. 마치며   sawtooth공식 doc에 있는 내용을 거의 다 해봤네요! 꺄오꺄오! 다음에 또 만나요!      ","categories": ["Sawtooth-Starter"],
        "tags": [],
        "url": "http://localhost:4000/sawtooth-starter/sawtooth-starter10/",
        "teaser":null},{
        "title": "Simple IoT accelerometer game Tutorial",
        "excerpt":"Learn how to capture and send sensor data to the cloud using Watson IoT Platform and then analyze that data using Watson Studio  1. Overview  디바이스의 센서데이터를 cloud상에 저장시키고, 저장된 데이터를 왓슨스튜디오로 분석하여 센싱데이터의 에너지 총량을 도출할 수 있는 application입니다.   IBM Developer blog에 게재된 “Create a fun, simple IoT accelerometer game“를 따라 진행해보도록 하겠습니다.      기대효과         IoT에 대한 흥미유발     IBM Cloud 사용법과, Watson Studio의 사용법 숙지     다수가 모인 자리에서 킬링타임용 게임진행      2. Prerequisites  IBM Cloud와 IBM Watson계정을 만들어주세요.  IBM Cloud : link  IBM Watson : link  +) 센서 데이터를 수집해야 하므로, 테스트할 기기로 스마트폰 또는 노트북을 지참해주세요.   3. Deploy Application  센서데이터를 수집할 수 있는 웹 애플리케이션을 클라우드상에 배포해보는 과정입니다.   다음 버튼을 클릭해서 IBM cloud상에 배포해봅시다.       출처: romeokienzler/discover-iot-sample    cloud에 배포하기전 설정 화면이 나타납니다.       주의 : 주의해야할 점은 지역을 댈러스로 선택해야 한다는 것입니다. 댈러스 외의 다른 지역을 선택하면 앱을 실행하기 위한 몇가지 플러그인이 존재하지 않는 것 같습니다.    지역을 선택한 뒤, API키 작성을 눌러 API키를 생성하고 Deploy버튼을 눌러 앱을 클라우드상에 배포합니다.       Deliver Pipeline을 클릭해보면 github에서 가져온 코드가 클라우드상에 배포되고 있는 모습을 확인할 수 있습니다.      몇가지 설정을 바꾸기 위해 Deploy Stage의 단계구성을 클릭해줍니다.     아래 사진과 같이 입력유형을 Git 저장소, 분기를 master로 바꿔준 뒤 저장해 줍니다.    저장하고 난 뒤, 빌드부터 새로 재시작해줍니다.   앱이 정상적으로 가동된다면 앱URL방문을 클릭합니다.     방문하게 되면, Step1에 하나의 링크가 보이게 됩니다. 이 링크는 디바이스에서 센서데이터를 측정해서 화면에 띄워주는 웹기반 application입니다.    이 링크를 따라 접속해봅시다.   User의 Id와 Pw를 입력하고나면 연결되었다는 표시와 함께 Movement, Acceleration에 관한 센서값들을 확인할 수 있습니다.     지금까지 과정은 단순히 클라우드에 앱을 배포하는 것입니다. 의미있는 데이터를 뽑아내기위해, 센서데이터들을 저장할 수 있는 DB가 필요합니다. 다음 챕터에서는 데이터들을 저장시킬 수 있는 DB설정에 대해 다뤄보겠습니다.   4. Replace IoT Service &amp; Set NoSQLDB  센서데이터를 클라우드로 가져오기 위해서, Node-Red라는 오픈소스 GUI flow 에디터를 사용하겠습니다. Node-Red를 통해 디바이스에서 송신되는 MQTT기반 데이터들을 DB에 저장할 것입니다.   첫번째로, Internet of Things Platform Starter로 들어가서 앱을 작성해 줍니다.     경로 : 카탈로그&gt;스타터 킷&gt;Internet of Things Platform 스타터      생성하기를 누른 뒤, Running상태가 되면 왼쪽 메뉴에서 연결 항목으로 들어갑니다.   기본적으로 생성된 IoT Platform서비스를 해제 시킵니다. 그 뒤, 서비스 인스턴트도 삭제시켜줍니다.    re-stage할것이냐는 메세지가 뜰텐데 cancel을 누르고 다음 단계로 진행합니다.   연결작성(Connect existing)버튼을 누르고 discover-iot-try-service를 연결시킵니다. 그 뒤 리스테이징을 눌러 앱을 재시작시킵니다.     앱이 Running 상태가 되면, discover-iot-try-service를 클릭해 Watson IoT Platform을 시작시킵니다.     실행시키면 왼쪽 메뉴가 가려져서 잘 안보이는데 마우스를 올리면 잘 보이게 됩니다. 자물쇠처럼 생긴 Security메뉴를 클릭합니다. 뜨는 리스트 중, 연결보안(Connection Security) 수정버튼을 클릭합니다.    Security Level을 TLS Optional(TLS 선택적)으로 변경시켜준 뒤, Refresh 시켜줍니다.     TLS Optional  TLS Optional에서는 장치가 TLS 1.1 이상과 연결하지 않을 때 네트워크 통신의 암호화를 강제 실행하지 않습니다. 비TLS 연결을 사용하면 네트워크에 있는 다른 사용자가 디바이스 신임 정보와 민감한 데이터를 볼 수 있습니다. TLS Optional을 통해 전송되는 데이터를 보호할 책임은 전적으로 사용자에게 있습니다.    저장하고 다시 IBM Cloud Foundry Apps로 돌아옵니다.  App URL방문을 통해 Node-Red를 실행시킵시다.    가이드에 따라 쭉쭉 진행한 뒤, 에디터 화면을 살펴보면 요상한 그래프들이 많이 보일겁니다. 다 지우고 아래 사진과 같이 세팅해 주세요.     IBM IoT노드의 Authentication을 Bluemix Service로 바꿔줍니다. 이는 IBM IoT node가 MQTT브로커와 연결하기위한 credential를 Cloud Foundry credentials injection을 통해 가져오겠다는 뜻입니다.     설정이 끝났다면 오른쪽상단의 Deploy버튼을 눌러줍니다.  이전에 배포했던 IoT app을 디바이스에서 실행시킨 뒤, Debug탭을 눌러 날아오는 msg들을 확인할 수 있습니다.    날아가는 데이터들은 discover-iot-try-service의 Watson IoT Platform&gt;Divices탭에서 확인할 수 있습니다.     근데 msg가 object타입으로 날아와서 한눈에 알아보기가 힘드네요. function노드를 통해 msg를 꾸며봅시다.    //function에 들어가야 할 부분 msg.payload = { X : msg.payload.d.ax, Y : msg.payload.d.ay, Z : msg.payload.d.az, SENSORID : msg.payload.d.id } return msg;   날아오는 데이터를 Debug탭에서 확인해보면 바뀐것을 확인할 수 있습니다.     이제 클라우드상에 데이터를 저장할 NoSQL DB로서 Cloudant를 추가시킵니다.     IBM Cloudant는 ApacheCouchDB에 기반하고 있습니다.           추가적으로 데이터가 너무 빨리 송신되는 것을 막기 위해, delay node를 추가적으로 생성해 줍시다.     노드의 전체 도식도는 다음과 같습니다.     이제 센서데이터를 송신받아 Cloudant에 저장하는 것까지 완성되었습니다!  하지만 단순히 데이터를 저장만 하는 것은 아무런 의미를 갖지 못합니다. 때문에 데이터를 분석하여 의미있는 값을 도출해 내는 것이 중요합니다.   5. Analyze Data with Watson Studio     왓슨스튜디오를 처음 사용하는 유저는 먼저 상단의 Upgrade 버튼을 누른 뒤, Watson Studio와 Knowledge Catalog Bundle들을 설치해주세요.      새로운 프로젝트를 생성해 주세요.       프로젝트에 Object Storage를 추가해 줍니다.       추가하고나서 Refresh버튼을 눌러줍니다.     프로젝트를 생성하고 나서, Spark 서비스를 추가시킵니다.      프로젝트의 초기 설정은 끝!   다음은 실제로 어떻게 데이터를 분석할 것인지 정하는 Notebook을 구성해봅시다.  프로젝트 상단에 Add to project버튼을 눌러보면 Notebook을 생성하는 버튼이 있습니다.   이 튜토리얼은 하단의 github링크로부터 Notebook을 가져올 것입니다.  https://raw.githubusercontent.com/romeokienzler/developerWorks/master/boomboomshakeshakesparkv2.ipynb      runtime은 방금전에 만들었던 spark서비스를 가져옵니다.   Notebook에서 분석용으로 사용할 DB Connection을 만들어줘야 합니다. 다음 사진을 보고 project page로 돌아가줍니다.    Connection을 클릭하고, 만들었던 Cloudant를 클릭한 뒤, Create버튼을 클릭해줍니다.     다시 Notebook페이지로 돌아가서 하단의 코드블럭안에 Connection을 Insert합니다.  #PLEASE INSERT TO CREDENTIALS TO CLOUDANT HERE USING THE IBM WATSON STUDIO CONNECTIONS TAB RIGHT TO THIS NOTEBOOK #이곳에 Insert        주의 : DB를 넣는 코드블럭 밑에 credentials을 참조하는 변수가 있습니다. credentials_1을 변수네임으로써 사용하고 있으므로 Connection을 Insert한 뒤, 이름을 credentials_1로 바꿔주어야 합니다.    코드를 RUN하기 전에 고쳐야할 부분이 몇가지 있습니다. 패키지를 다운로드 받는 부분인 첫번째 코드블럭을 봐주세요.  import pixiedust pixiedust.installPackage(\"https://github.com/romeokienzler/developerWorks/raw/master/coursera/spark-sql-cloudant_2.11-2.3.0-SNAPSHOT.jar\") pixiedust.installPackage(\"com.typesafe:config:1.3.1\") pixiedust.installPackage(\"com.typesafe.play:play-json_2.11:jar:2.5.9\") pixiedust.installPackage(\"org.scalaj:scalaj-http_2.11:jar:2.3.0\") pixiedust.installPackage(\"com.typesafe.play:play-functional_2.11:jar:2.5.9\")   위 코드의 첫줄인 github에서 패키지를 다운로드 받는 부분은 주석처리를 해야합니다.  #pixiedust.installPackage(\"https://github.com/romeokienzler/developerWorks/raw/master/coursera/spark-sql-cloudant_2.11-2.3.0-SNAPSHOT.jar\")  첫번째로 예제로 올라온 링크가 유효하지 않다는 점.  두번째로 유효한 링크를 넣어도 ‘NoneType’ object has no attribute ‘strip’ 에러가 발생합니다.  없애도 정상적으로 돌아갑니다…     spark-sql-cloudant_2.11-2.3.0-SNAPSHOT.jar파일이 정확히 어떤 역할을 하고, 없어도 제대로 돌아가는 이유에 대해서는 파악하지 못했습니다.    다음으로 바꿔야 할 부분은 DB의 네임입니다.  df=spark.read.load({'cloudant의 이름'}, 'org.apache.bahir.cloudant') df.createOrReplaceTempView('data')   이 튜토리얼에서 제가 썻던 이름은 harlemshake였으니 다음과 같이 구성될 것입니다.  df=spark.read.load('harlemshake', 'org.apache.bahir.cloudant') df.createOrReplaceTempView('data')   수정해야할 부분을 수정했다면 Cell&gt;Run All 버튼을 클릭합시다.    Cloudant에 접속하여 데이터를 전송했던 id들의 리스트가 Notebook에서 정의했던 규칙대로 정렬된 모습을 확인할 수 있습니다.      에너지 총량 계산 방법 :    select sqrt(sum(X*X)+sum(Y*Y)+sum(Z*Z)) as energy, SENSORID from data group by SENSORID order by energy desc        energy값으로 내림차순     -튜토리얼 끗-      ","categories": ["Simple-Tutorial"],
        "tags": [],
        "url": "http://localhost:4000/simple-tutorial/iot-tutorial/",
        "teaser":null}]
